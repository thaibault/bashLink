
> bashlink@1.0.94 document:show /home/torben/cloud/data/public/project/repository/bashlink
> ./documentation.sh

# Package bashlink
## Module bashlink.arguments
The arguments module provides an argument parser that can be used in
functions and scripts.

Different functions are provided in order to parse an arguments array.

```bash
>>> _() {
>>>     local value
>>>     bl.arguments.set "$@"
>>>     bl.arguments.get_parameter param1 value
>>>     echo "param1: $value"
>>>     bl.arguments.get_keyword keyword2 value
>>>     echo "keyword2: $value"
>>>     bl.arguments.get_flag --flag4 value
>>>     echo "--flag4: $value"
>>>     # NOTE: Get the positionals last
>>>     bl.arguments.get_positional 1 value
>>>     echo 1: "$value"
>>>     # Alternative way to get positionals: Set the arguments array to
>>>     # to all unparsed arguments.
>>>     bl.arguments.apply_new
>>>     echo 1: "$1"
>>> }
>>> _ param1 value1 keyword2=value2 positional3 --flag4
param1: value1
keyword2: value2
--flag4: true
1: positional3
1: positional3
```
## Module bashlink.array
This module implements utility functions concerning arrays.
## Module bashlink.changeroot
The changeroot module implements utility functions concerning advanced
change roots with kernel filesystem application interfaces.
## Module bashlink.cli
This module provides variables for printing colorful and unicode glyphs.
The Terminal features are detected automatically but can also be
enabled/disabled manually.

[bl.cli.enable_color](#function-bl_cli_enable_color) and
[bl.cli.enable_unicode_glyphs](#function-bl_cli_enable_unicode_glyphs)
## Module bashlink.cracking
The cracking module implements utility functions to make a system
unusable or trigger unexpected behavior.
## Module bashlink.dependency
The dependency module implements utility functions to check current
environment again needed assumptions.
## Module bashlink.dictionary
The dictionary module implements utility functions concerning dictionary
operations.
## Module bashlink.display
The display module implements utility functions concerning display
configuration.
## Module bashlink.doctest
This module implements function and module level testing via documentation
strings. Tests can be run by invoking:

```bash
doctest.sh file1 folder1 file2 ...
```

Options:

```
--help|-h               Print help message.
--prevent-side-by-side  Prevents printing differences of failing
tests side by side.
--no-check-undocumented Do not warn about undocumented functions.
--use-nounset           Accessing undefined variables produces error.
--verbose|-v            Be more verbose
```

Example output for `./doctest.sh --verbose arguments.sh`

```bash
[info:doctest:xxx] bl.arguments:[PASS]
[info:doctest:xxx] bl.arguments.get_flag:[PASS]
[info:doctest:xxx] bl.arguments.get_keyword:[PASS]
[info.doctedt:xxx] bl.arguments.get_parameter:[PASS]
[info:doctest:xxx] bl.arguments.get_positional:[PASS]
[info:doctest:xxx] bl.arguments.set:[PASS]
[info:doctest:xxx] bl.arguments - passed 6/6 tests in 918 ms
[info:doctest:xxx] Total: passed 1/1 items in 941 ms
```

A docstring can be defined for a function by defining a variable named
`__documentation__` at the function scope. On the module level, the
variable name should be `<module_name>__documentation__` (e.g.
`bl_arguments__documentation__` for the example above). NOTE: The
"docstring" needs to be defined with single quotes. Code contained in a
module level variable named `<module_name>__bl_doctest_setup__` will be run
once before all the tests of a module are run. This is useful for defining
mockup functions/data that can be used throughout all tests.

```bash
>>> echo bar
bar
```
```bash
>>> echo $(( 1 + 2 ))
3
```
```bash
>>> echo foo
foo
```
```bash
>>> echo bar
bar
```
Single quotes can be escaped like so:

```bash
>>> echo '$foos'
$foos
```
Or so

```bash
>>> echo '$foos'
$foos
```
Some text in between.

Multiline output
```bash
>>> local i
>>> for i in 1 2; do
>>>     echo $i;
>>> done
1
2
```
Check ellipsis support

```bash
>>> local i
>>> for i in 1 2 3 4 5; do
>>>     echo $i;
>>> done
+bl.doctest.multiline_ellipsis
1
2
...
```
Multi line ellipsis are non greedy.

```bash
>>> local i
>>> for i in 1 2 3 4 5; do
>>>     echo $i;
>>> done
+bl.doctest.multiline_ellipsis
1
...
4
5
```
Ellipsis matches one line.

```bash
>>> local i
>>> for i in 1 2 3 4 5; do
>>>     echo $i;
>>> done
+bl.doctest.ellipsis
1
...
...
4
5
```
Each testcase has its own scope:

```bash
>>> local testing="foo"; echo $testing
foo
```
```bash
>>> [ -z "${testing:-}" ] && echo empty
empty
```
Check for syntax error in test code:

```bash
>>> f() {a}
+bl.doctest.multiline_contains
{a}
```
## Module bashlink.documentation
The documentation module implements function and module level documentation
generation in markdown.
## Module bashlink.exception
```bash
>>> _() {
>>>    bl.exception.try {
>>>        echo $1
>>>    } bl.exception.catch
>>>        true
>>> }
>>> _ 2
2
```
```bash
>>> local a=2
>>> bl.exception.try {
>>>     a=3
>>> } bl.exception.catch {
>>>     a=4
>>> }
>>> echo "$a"
3
```
```bash
>>> bl.exception.activate
>>> false
+bl.doctest.contains
+bl.doctest.multiline_ellipsis
Traceback (most recent call first):
...
```
```bash
>>> bl.exception.activate
>>> bl.exception.try {
>>>     false
>>> } bl.exception.catch {
>>>     echo caught
>>> }
caught
```
Exception in a subshell:

```bash
>>> bl.exception.activate
>>> ( false )
+bl.doctest.contains
+bl.doctest.multiline_ellipsis
Traceback (most recent call first):
...
+bl.doctest.contains
Traceback (most recent call first):
...
```
```bash
>>> bl.exception.activate
>>> bl.exception.try {
>>>     (false; echo "this should not be printed")
>>>     echo "this should not be printed"
>>> } bl.exception.catch {
>>>     echo caught
>>> }
caught
```
Nested exception:

```bash
>>> bl_exception_foo() {
>>>     true
>>>     bl.exception.try {
>>>         false
>>>     } bl.exception.catch {
>>>         echo caught inside foo
>>>     }
>>>     false # this is caught at top level
>>>     echo this should never be printed
>>> }
>>> bl.exception.try {
>>>     bl_exception_foo
>>> } bl.exception.catch {
>>>     echo caught
>>> }
caught inside foo
caught
```
```bash
>>> bl.exception.activate
>>> bl_exception_foo() {
>>>     bl.exception.try {
>>>         false
>>>     } bl.exception.catch {
>>>         echo caught
>>>     }
>>>     echo this should be printed
>>> }
>>> bl_exception_foo || echo info
+bl.doctest.contains
+bl.doctest.multiline_ellipsis
Error: Context does not allow error traps.
Traceback (most recent call first):
...
this should be printed
```
exception are implicitly active inside try blocks:

```bash
>>> foo() {
>>>     echo $1
>>>     true
>>>     bl.exception.try {
>>>         false
>>>     } bl.exception.catch {
>>>         echo caught inside foo
>>>     }
>>>     false # this should raise an error if exceptions are active
>>>     echo this should be printed if exceptions are not active
>>> }
>>> foo "exception NOT ACTIVE:"
>>> bl.exception.activate
>>> foo "exception ACTIVE:"
+bl.doctest.multiline_ellipsis
exception NOT ACTIVE:
caught inside foo
this should be printed if exceptions are not active
exception ACTIVE:
caught inside foo
+bl.doctest.contains
Traceback (most recent call first):
...
```
Exception inside conditionals:

```bash
>>> bl.exception.activate
>>> false && echo "should not be printed"
>>> (false) && echo "should not be printed"
>>> bl.exception.try {
>>>     (
>>>         false
>>>         echo "should not be printed"
>>>     )
>>> } bl.exception.catch {
>>>     echo caught
>>> }
caught
```
Print a caught exception traceback.

```bash
>>> bl.exception.try {
>>>     false
>>> } bl.exception.catch {
>>>     echo caught
>>>     echo "$bl_exception_last_traceback"
>>> }
+bl.doctest.multiline_contains
caught
Traceback (most recent call first):
```
Different syntax variations are possible.

```bash
>>> bl.exception.try {
>>>     ! true
>>> } bl.exception.catch {
>>>     echo caught
>>> }
```
```bash
>>> bl.exception.try
>>>     false
>>> bl.exception.catch_single {
>>>     echo caught
>>> }
caught
```
```bash
>>> bl.exception.try
>>>     false
>>> bl.exception.catch_single
>>>     echo caught
caught
```
```bash
>>> bl.exception.try {
>>>     false
>>> }
>>> bl.exception.catch_single {
>>>     echo caught
>>> }
caught
```
```bash
>>> bl.exception.try {
>>>     false
>>> }
>>> bl.exception.catch_single
>>> {
>>>     echo caught
>>> }
caught
```
## Module bashlink.filesystem
Provides filesystem aware utility functions.
## Module bashlink.globals
The globals module provides generic re-usable variables.
## Module bashlink.logging
The available log levels are:

- error
- critical
- warn (or warning)
- info
- debug

Supported output types for commands and logging are:

- std (Outputs to standard output)
- off (does not output anything)
- file (outputs to given file)
- tee (outputs to both: given file and standard output)

Supported type of configurable logging files

- Logging output
- Error logging output
- Command output
- Error command output

NOTE: this module saves and provided given standard und error file
descriptors to descriptors to "5" and "6". So you can enforce corresponding
output via `command 1>&5 2>&6`.
This is needed to restore them later via `bl.logging.set_file_descriptors`.
Logging outputs are alway piped through file descriptor "3" and "4". So
your able to write your own logging function by logging to this
descriptors: `custom_logging_function 1>&3 2&>4`.

The standard loglevel is critical

```bash
>>> bl.logging.get_level
>>> bl.logging.get_commands_level
critical
critical
```
```bash
>>> bl.logging.is_enabled error; echo $?
0
```
```bash
>>> bl.logging.error error-message
>>> bl.logging.critical critical-message
>>> bl.logging.warn warn-message
>>> bl.logging.info info-message
>>> bl.logging.debug debug-message
+bl.doctest.multiline_contains
error-message
critical-message
```
If the output of commands should be printed, the commands_level needs to be
greater than or equal to the log_level.

```bash
>>> bl.logging.set_level critical
>>> bl.logging.set_commands_level debug
>>> echo foo
```
```bash
>>> bl.logging.set_level info
>>> bl.logging.set_commands_level info
>>> echo foo
foo
```
Another logging prefix can be set by overriding "bl_logging_get_prefix".

```bash
>>> bl_logging_get_prefix() {
>>>     local level=$1
>>>     echo "[myprefix - ${level}]"
>>> }
>>> bl.logging.critical foo
[myprefix - critical] foo
```
## Module bashlink.module
Central module import mechanism. To scope modules and ensure running each
module only once.
## Module bashlink.network
The network module implements utility functions concerning network
confgurations.
## Module bashlink.number
The number module implements utility functions concerning numbers.
## Module bashlink.pacman
This module implements utility functions concerning the package manager
`pacman`.
## Module bashlink.path
The path module implements utility functions concerning path.
## Module bashlink.ssh
This module implements utility functions concerning ssh connections.
## Module bashlink.string
This module implements utility functions concerning strings.
## Module bashlink.time
The time module implements utility functions concerning time measurments.
## Module bashlink.tools
This module provides generic utility functions.
## Module bashlink.ui
This module provides helper methods to use low level graphical interfaces.
